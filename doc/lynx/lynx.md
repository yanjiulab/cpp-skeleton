# Lynx

## 程序配置

程序配置是一个十分重要的部分，用于程序初始化设置参数，一般而言，程序具有以下几种和外部交互的方式：

- 命令行参数：程序运行时携带的参数，一般通过主函数参数 `int main(int argc, char** argv)` 进行捕捉。
- 文件系统：程序通过读入配置文件进行参数设置，目前，常用的配置文件分为 5 种：
  - INI 格式：简单的配置文件格式，以节（`[section]`）划分，采用 `key=value` 键值对，支持注释（`;` 或 `#` 开头），结构直观，适合简单配置，如 Windows 系统配置文件。
  - TOML：为配置文件设计的格式，兼容 INI 的简洁性，增加了数据类型（字符串、数字、布尔值等）、数组、嵌套结构和日期时间类型，语法严格且易读，常用于 Rust、Python 等项目配置。
  - JSON：轻量级数据交换格式，基于 JavaScript 语法，使用键值对 `{"key": value}` 和数组`[ ]`，支持字符串、数字、布尔值、null 及嵌套结构，无注释，跨语言兼容性强，是网络数据传输的主流格式。
  - YAML：强调可读性的格式，使用缩进表示层级，支持列表（- 开头）、键值对（key: value）、多行字符串和注释（#开头），数据类型丰富，常用于配置文件（如 Docker、Kubernetes）和数据序列化。
  - 自定义格式：例如 nginx 等软件自定义的 conf 文件格式。
- 环境变量：环境变量是操作系统或应用程序中存储 “全局配置信息” 的键值对（Key-Value），本质是 “给系统 / 程序用的‘全局变量’”—— 它不依赖具体文件，而是存在于操作系统的内存中，供所有运行的程序随时读取，用于实现 “配置与代码分离”“跨程序共享信息” 等核心需求。

[CLI11](https://github.com/CLIUtils/CLI11) 是一个命令行参数解析库，支持子命令，支持联动配置文件 TOML 和环境变量，十分符合笔者口味，因此 lynx 使用该库完成主要的配置系统构建。

在 TOML 文件中，可以对命令行参数的设置进行补充设置，如果命令行参数没有设置，那么可以作为补充，如果配置文件也没有该项，则会查看是否提供了同名的环境变量（当然也要进行绑定设置）。在 TOML 文件中，除了定义与命令行参数同名的键值对，还可以定义其他设置，这部分内容不会影响命令行参数的结果，结合 [toml11](https://github.com/ToruNiina/toml11) 库对 TOML 文件进行读写，并将所有配置结果存储在 `lynx::ConfigData` 结构体中，供程序进行使用。

> go 语言有一个十分好用的配置库 [viper](https://github.com/spf13/viper)，可以作为所以其他语言的榜样，如果不嫌麻烦，可以模仿 viper 风格，实现一个完整的功能实现。但在 cpp 中 lynx 的配置已经足够使用。
>

## ASIO

lynx 作为一个网络服务守护进程，选择一个网络库十分重要。ASIO（Asynchronous Input/Output）是一个跨平台的 C++ 库，专注于提供高效的异步 I/O（输入 / 输出）操作能力，尤其在网络编程（TCP/UDP）、串口通信、定时器等场景中被广泛应用。

ASIO 不是 “封装好的网络框架”（如提供 HTTP 协议实现），而是 “底层异步 I/O 工具集”—— 它封装了操作系统的异步 I/O 接口（如 Linux 的epoll、Windows 的IOCP、BSD 的kqueue），提供统一的 C++ 接口，让开发者无需关注不同系统的底层差异，即可编写跨平台的高性能异步代码。

ASIO 目前有独立版本和 BOOST 版本，为了考虑不引入 BOOST 依赖，采用独立版本。许多库依赖 ASIO 编写，因此作为一般程序，学习使用 ASIO 是有价值的，用一套大而全的框架也会带来代码的飞速膨胀，与 lynx 的定位不符。

因此，可以说 ASIO 是 lynx 的基石，后续很多库，都是以基于 ASIO 为标准进行选择的。ASIO 官方提供了许多教程与示例，可以方便我们掌握其功能。网络编程中常用的主要包括：

- 基本网络套接字： UDP、TCP、ICMP、组播
- 定时器
- 信号

## 守护进程

网络服务程序一般是“后台”运行，很多情况下，开发者通过 `xxx &` 的方式，在命令末尾加 `&`，让程序在 “终端的后台进程组” 中运行，本质上这是“终端的子进程”。这有如下隐患：

- 依赖启动它的终端，是终端的 “子进程”,终端退出，进程退出。
- 标准输出（stdout）、标准错误（stderr）默认仍关联终端，可能在终端打印信息，因此造成尽管程序在后台执行了，但是“前台终端”仍有可能输出“后台”程序的输出，如果前台启动了其他程序，会污染该程序的输出。
- 无自动重启机制，进程退出后需手动重新启动。

另一些人使用 `nohup` + `&` 的作用：`nohup` 让进程 “忽略 SIGHUP 信号”（终端关闭时不退出），`&` 让进程后台运行，本质是 “增强版后台进程”，仍未脱离终端的环境依赖。

因此，实际上很多开发者需要的是“守护进程”功能，然而却错误的实现为“后台”启动程序。

守护进程是一种特殊的系统进程，完全脱离终端控制，在系统后台长期运行（如 nginx、mysql 服务），具备 “独立生命周期、自动重启（可选）、日志管理” 等特性，是操作系统级的后台服务。

让“普通程序”变为“守护进程”十分简单，有两种方式：

- 程序内部使用 daemonize 相关函数完成 fork 等过程，直接变为守护进程，lynx 提供了 `-d` 参数启动，来进行守护进程运行。
- 使用 systemd 系统完成，具有完整的管理流程，同系统服务一样。

## HTTP

ASIO 没有提供 HTTP 功能，尽管官方提供了 HTTP 的示例，但其可用程度较低。因此 lynx 选择了 [cinatra](https://github.com/qicosmos/cinatra) 作为高性能 HTTP 库。

## 序列化

程序在内容中以各种数据结构进行组织，当需要进行网络传输，或者本地保存时，需要进行序列化。大体而言，序列化分为：

- 文本序列化：主要是 JSON 序列化，可以方便的进行网络传输。
- 二进制序列化：基于特定格式的序列化，常用的二进制序列化有 protobuf 或者 flatbuffers（lynx 选择）。

## RPC

TODO

## ORM

对于大量数据，是不会存储于数据对象中的，通常我们需要利用数据库来存储，除此之外，数据库提供了额外的功能，例如高效查找、跨语言、数据稳定性高等。因此，任何一种语言都有其与数据库的接口。

ORM（Object-Relational Mapping，对象关系映射）是一种编程技术，用于解决编程语言中的对象模型与数据库中的关系模型之间的不匹配问题。简单来说，ORM 将数据库表映射为编程语言中的类，将表中的行映射为对象，让开发者可以用面向对象的方式操作数据库，而无需编写复杂的 SQL 语句。

## coroutines

## REPL

REPL 是 **Read-Eval-Print Loop**（读取 - 求值 - 打印循环）的缩写，是一种交互式编程环境，允许开发者输入代码片段、立即执行并查看结果，形成 “输入→执行→反馈” 的循环。它是开发者调试代码、验证逻辑、学习新语言的核心工具，几乎所有现代编程语言（如 Python、JavaScript、Java 等）都内置或提供对应的 REPL 环境。

在后台守护进程中，可以通过提供 REPL 接口，使得使用者获得与进程交互式的体验，从而可以查看守护进程状态。lynx 提供的 REPL 使用了 [cli](https://github.com/daniele77/cli) 库，支持标准输入、文件以及 Telnet 协议（依赖 asio），下图展示了 telnet 交互的例子。

![repl-telnet](repl.gif)

使用 cli 也十分简单，只需三步：

1. 创建 io_ctx 上下文
2. 初始化 repl 对象
3. 开启需要的 repl 会话

```cpp
// 1. 创建 io_ctx 上下文
asio::io_context io_ctx;
// 2. 初始化 repl 对象
lynx::Repl repl(io_ctx);
// 3. 开启需要的 repl 会话
// 开启终端会话
repl.StartLocalSession();
repl.local_session->ExitAction(
    [&](auto& out) {
        out << "Closing App by Cli...\n";
        rest.server().stop();
        repl.Stop();
    });
// 开启 telnet 会话
repl.StartTelnetSession(8888);
// 开启文件会话
std::ifstream infile("etc/repl.in");
std::ofstream outfile("etc/repl.out");
repl.StartFileSession(infile, outfile);
```

三种不同的会话方式用途不同：

1. 本地终端会话：用于程序直接前台运行时交互，一般调试使用。默认情况下，`exit` 表示直接退出，但通常情况下，我们希望 `exit` 可以进行资源清理（例如关闭一个 REST HTTP 服务器）后再退出，那么我们需要提供自定义的 `ExitAction` 回调函数。
2. 远程 telnet 会话：用于程序守护进程运行时交互。多个使用者可以同时通过 telnet 协议连接进程进行交互。注意此时 `exit` 仅表示断开 telnet 连接，不会导致程序退出。
3. 文件会话：我们可以将命令逐行组织成文件方式输入，然后将命令的结果以文件方式输出。在两种情况下特别有用：
   - 如果定义了许多设置命令，例如 `timeout 3` 表示设置超时时间为 3 秒。那么 repl.in 可以直接作为配置文件进行程序预配置，灵活度极高。
   - 如果程序需要一系列状态的跳转，才能够到达某个状态，那么可以将 repl.in 作为一个“导演脚本”，结合日志输出观察每一步的状态，还原出特定步骤下的程序状态。

设置命令同样十分简单，通常情况下，我们可以将 `timeout` 不带参数作为 get 操作，带参数作为 set 操作。

```cpp
rootMenu->Insert(
        "timeout",
        [&](std::ostream& out, int sec) {
            timeout = sec
            out << "Set timeout to: " << timeout << std::endl; 
        },
        "Set timeout");
rootMenu->Insert(
        "timeout",
        [&](std::ostream& out) { out << "timeout: " << timeout << std::endl;},
        "Get timeout");
```

交互时可以通过 timeout 动态的设置/获取超时时间。

```bash
cli> timeout 3
Set timeout to: 3
cli> timeout 
timeout: 3
```
